package common

import (
	"fmt"
	"reflect"
	"strings"
	"unicode"
)

func QuerierToSqlCondition(argMap *map[string]interface{}, querier interface{}, tableName ...string) (string, *map[string]interface{}) {
	tableNameStr := ""
	if len(tableName) > 0 {
		tableNameStr = tableName[0]
	}
	if argMap == nil {
		argMap = &map[string]interface{}{}
	}

	typ := reflect.TypeOf(querier)
	val := reflect.ValueOf(querier)

	if typ.Kind() != reflect.Ptr || typ.Elem().Kind() != reflect.Struct {
		panic("ToWhere: Expected a pointer to a struct")
	}

	typ = typ.Elem()
	val = val.Elem()

	cond := ""
	firstField := true
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		value := val.Field(i)

		// Check if the field should be skipped based on the tag
		if tag := field.Tag.Get("cond"); tag == "-" {
			continue
		}

		if field.PkgPath == "" {
			if value.Kind() == reflect.Ptr {
				if value.IsNil() {
					continue
				}
				// value = value.Elem()
			}
			if value.Kind() == reflect.Struct {
				subCond, _ := QuerierToSqlCondition(argMap, value.Addr().Interface(), tableNameStr)
				if subCond != "" {
					if !firstField {
						cond += " AND "
					}
					cond += subCond
				}
				continue
			}
			if !value.IsZero() {
				if !firstField {
					cond += " AND "
				}
				firstField = false
				if len(tableNameStr) > 0 {
					cond += fmt.Sprintf("%s.%s = @%s", tableNameStr, FieldToSqlName(field.Name), field.Name)
				} else {
					cond += fmt.Sprintf("%s = @%s", FieldToSqlName(field.Name), field.Name)
				}
				(*argMap)[field.Name] = value.Interface()
			}
		}
	}
	return strings.TrimSpace(cond), argMap
}

// Generated by kimi
func FieldToSqlName(input string) string {
	var result strings.Builder
	result.Grow(len(input)) // Optimize memory allocation

	// If the input string is not empty, convert the first letter to lowercase without adding an underscore
	if len(input) > 0 {
		result.WriteRune(unicode.ToLower(rune(input[0])))
	}

	// Iterate through the rest of the string starting from index 1
	for i := 1; i < len(input); i++ {
		r := rune(input[i])
		if unicode.IsUpper(r) {
			// If the character is uppercase, convert it to lowercase and add an underscore before it
			result.WriteRune('_')
			result.WriteRune(unicode.ToLower(r))
		} else {
			// Otherwise, add the character as is
			result.WriteRune(r)
		}
	}

	return result.String()
}
